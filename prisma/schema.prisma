generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  SUPER_ADMIN
  ADMIN
  MANAGER
  VIEWER
}

model Account {
  id   Int    @id @default(autoincrement())
  name String

  users User[]
  shops Shop[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

model User {
  id           Int    @id @default(autoincrement())
  email        String @unique
  passwordHash String
  role         Role   @default(VIEWER)

  accountId Int
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Sessões normais (login)
  sessions Session[] @relation("UserSessions")

  // Sessões onde este usuário é o "realUser" (impersonation)
  impersonations Session[] @relation("SessionRealUser")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([accountId, role])
}

model Session {
  id String @id @default(cuid())

  // Usuário logado (ou usuário "atuando", caso impersonation esteja ativo)
  userId Int
  user   User @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)

  // Loja ativa (Shop.id) para resolver as rotas /shops/:shopId/... ignorando :shopId
  activeShopId Int?
  activeShop   Shop? @relation(fields: [activeShopId], references: [id], onDelete: SetNull)

  // Impersonation (para SUPER_ADMIN)
  realUserId    Int?
  realUser      User?   @relation("SessionRealUser", fields: [realUserId], references: [id], onDelete: SetNull)
  impersonating Boolean @default(false)

  createdAt DateTime @default(now())
  expiresAt DateTime

  @@index([userId])
  @@index([activeShopId])
  @@index([expiresAt])
}

/**
 * ===== Seus models atuais (com ajustes mínimos) =====
 * Observação: accountId está nullable (Int?) para preservar dados no Render na primeira migration.
 * Depois do backfill, você torna obrigatório (Int).
 */
model Shop {
  id Int @id @default(autoincrement())

  // Vínculo multi-tenant (Migration 1: nullable / Migration 2: obrigatório)
  accountId Int?
  account   Account? @relation(fields: [accountId], references: [id], onDelete: Cascade)

  shopId BigInt  @unique
  region String?
  status String  @default("UNKNOWN")

  tokens   OAuthToken?
  orders   Order[]
  products Product[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  sessions  Session[]

  @@index([accountId])
}

model OAuthToken {
  id Int @id @default(autoincrement())

  shopId Int  @unique
  shop   Shop @relation(fields: [shopId], references: [id], onDelete: Cascade)

  accessToken           String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshToken          String?   @db.Text
  refreshTokenExpiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Order {
  id Int @id @default(autoincrement())

  shopId Int
  shop   Shop @relation(fields: [shopId], references: [id], onDelete: Cascade)

  orderSn     String
  orderStatus String?
  region      String?
  currency    String?

  daysToShip Int?
  shipByDate DateTime?

  shopeeCreateTime DateTime?
  shopeeUpdateTime DateTime?

  bookingSn             String?
  cod                   Boolean?
  advancePackage        Boolean?
  hotListingOrder       Boolean?
  isBuyerShopCollection Boolean?
  messageToSeller       String?  @db.Text

  reverseShippingFee Int?

  addressSnapshots OrderAddressSnapshot[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([shopId, orderSn])
  @@index([shopId, orderStatus])
  @@index([shopId, shipByDate])
}

model OrderAddressSnapshot {
  id Int @id @default(autoincrement())

  orderId Int
  order   Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  name        String?
  phone       String?
  town        String?
  district    String?
  city        String?
  state       String?
  region      String?
  zipcode     String?
  fullAddress String? @db.Text

  addressHash String

  createdAt DateTime @default(now())

  @@index([orderId, createdAt])
  @@index([addressHash])
}

model Product {
  id Int @id @default(autoincrement())

  shopId Int
  shop   Shop @relation(fields: [shopId], references: [id], onDelete: Cascade)

  itemId      BigInt
  status      String?
  title       String?
  description String?  @db.Text
  ratingStar  Float?
  ratingCount Int?
  currency    String?
  priceMin    Int?
  priceMax    Int?
  itemSku     String?
  stock       Int?
  sold        Int?
  attributes  Json?
  logistics   Json?
  dimension   Json?
  weight      Float?
  daysToShip  Int?
  hasModel    Boolean?
  brand       String?
  categoryId  BigInt?

  shopeeCreateTime DateTime?
  shopeeUpdateTime DateTime?

  images ProductImage[]
  models ProductModel[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([shopId, itemId])
  @@index([shopId, status])
}

model ProductImage {
  id        Int     @id @default(autoincrement())
  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  url     String
  imageId String?

  @@index([productId])
}

model ProductModel {
  id Int @id @default(autoincrement())

  productId Int
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  modelId          BigInt
  name             String?
  sku              String?
  price            Int?
  stock            Int?
  sold             Int?
  ratingStar       Float?
  ratingCount      Int?
  shopeeCreateTime DateTime?

  @@unique([productId, modelId])
  @@index([productId])
}
